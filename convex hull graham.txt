
typedef struct
{
    ll  x, y;
} point;
priority_queue<payar, vector<payar>,  greater<payar> > pq;
vector< pair<payar,int > > vpp;
vector < payar >  vp;
deque <int> dq,tmpdq;
const int INF = 1 << 30;
#define eps 1e-16

point pnt[200000+50];
point c[200000+50];
point p0;
ll dis(point A, point B)
{
    return ( (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y));
}
inline ll area(const point &p1, const point &p2, const point &p3)
{
    return p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);
}
inline bool cmp(const point &a, const point &b)
{
    ll d = area(p0,a,b);
    if(d<0)
        return false;
    if(!d and  dis(p0,a) > dis(p0,b))
        return false;
    else
        return true;
}
ll polygonArea(int n )
{
    ll area = 0;
    ll j = n - 1;
    for (int  i = 0; i < n; i++)
    {
        ll tmp = (c[j].x + c[i].x) * (c[j].y - c[i].y);
        area +=tmp;
        j = i;
    }

    return abs(area) ;
}
int graham(int n )
{
    int i, j,pos = 0;

    for(i = 1 ; i<n ; i++)
    {
        if(pnt[i].y<pnt[pos].y || ( pnt[i].y==pnt[pos].y and pnt[i].x<pnt[pos].x ))
        {
            pos = i;
        }
        swap(pnt[0],pnt[pos]);
        p0 = pnt[0];
    }
    sort(&pnt[1],&pnt[n],cmp);

    int st = 0;
    for(int i = 0, sz = n; i < sz; i++){
        while(st>= 2 and area(c[st-2], c[st-1], pnt[i]) <= 0) st--;
        c[st++] = pnt[i];
    }
    int taken = st - 1;
    for(int i = n - 2; i >= 0 ; i--){
        while(st >= taken + 2 and area(c[st - 2], c[st - 1], pnt[i]) <= 0) st--;
        c[st++] = pnt[i];
    }

    return st-1;

}